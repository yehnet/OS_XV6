diff --git a/kernel/proc.c b/kernel/proc.c
index b433803..25eb3a0 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -40,22 +40,22 @@ struct spinlock wait_lock;
 void print_locks_position(int procLocks[], int threadLocks[])
 {
   printf("DEBUG ------Locks:\talloc\texit\tscheduler\tyield\tsleep\tkill\n");
-  printf("\t\t\t%d ", procLocks[0]);
-  printf("\t%d ", procLocks[1]);
-  printf("\t%d ", procLocks[2]);
-  printf("\t\t%d ", procLocks[3]);
-  printf("\t%d ", procLocks[4]);
-  printf("\t%d ", procLocks[5]);
+  printf("\t\t\t%d ", procLocks[0]); //alloc
+  printf("\t%d ", procLocks[1]);     //exit
+  printf("\t%d ", procLocks[2]);     //scheduler
+  printf("\t\t%d ", procLocks[3]);   //yield
+  printf("\t%d ", procLocks[4]);     //sleep
+  printf("\t%d ", procLocks[5]);     //kill
 
   printf("\n");
 
-  printf("\t\t\t%d ", threadLocks[7]);
-  printf("\t%d", threadLocks[1]);
-  printf("-%d", threadLocks[2]);
-  printf("\t%d ", threadLocks[3]);
-  printf("\t\t%d ", threadLocks[4]);
-  printf("\t%d ", threadLocks[5]);
-  printf("\t%d ", threadLocks[6]);
+  printf("\t\t\t%d ", threadLocks[7]); //alloc
+  printf("\t%d", threadLocks[1]);      //exit
+  printf("-%d", threadLocks[2]);       //exit
+  printf("\t%d ", threadLocks[3]);     //scheduler
+  printf("\t\t%d ", threadLocks[4]);   //yield
+  printf("\t%d ", threadLocks[5]);     //sleep
+  printf("\t%d ", threadLocks[6]);     //kill
   // printf("%d ", threadLocks[i]);
 
   printf(" \n");
@@ -192,7 +192,6 @@ allocThread(struct proc *p)
   {
     // printf("DEBUG--------------allocthread acquire \n");
     acquire(&t->lock);
-    t->tlocks[7] = 1;
     if (t->state == UNUSED)
     {
       t->myNum = i;
@@ -223,7 +222,9 @@ found:
   t->tlocks[4] = 0;
   t->tlocks[5] = 0;
   t->tlocks[6] = 0;
-  t->tlocks[7] = 0;
+  t->tlocks[7] = 1;
+
+  p->tCounter++;
 
   if ((t->kstack = (uint64)kalloc()) == 0)
   {
@@ -282,16 +283,16 @@ allocproc(void)
     }
     else
     {
+      // printf("allocproc1\n");
       release(&p->lock);
     }
   }
   return 0;
 
 found:
-  p->plocks[0] = 1;
   p->pid = allocpid();
   p->state = USED;
-  p->plocks[0] = 0;
+  p->plocks[0] = 1;
   p->plocks[1] = 0;
   p->plocks[2] = 0;
   p->plocks[3] = 0;
@@ -299,11 +300,13 @@ found:
   p->plocks[5] = 0;
   p->plocks[6] = 0;
   p->plocks[7] = 0;
+  p->tCounter = 0;
 
   // Allocate a trapframe page.
   if ((p->start = kalloc()) == 0)
   {
     freeproc(p);
+    // printf("allocproc2\n");
     release(&p->lock);
     return 0;
   }
@@ -333,6 +336,7 @@ found:
   if (p->pagetable == 0)
   {
     freeproc(p);
+    // printf("allocproc3\n");
     release(&p->lock);
     return 0;
   }
@@ -375,6 +379,7 @@ freeThread(struct thread *t)
   t->parent = 0;
   t->xstate = 0;
   t->bsem_id = 0;
+  t->parent->tCounter--;
 }
 
 // free a proc structure and the data hanging from it,
@@ -482,8 +487,13 @@ void userinit(void)
   t->state = RUNNABLE;
   p->state = RUNNABLE;
 
+  t->tlocks[7]--;
   release(&t->lock);
+  p->plocks[0]--;
+  // print_locks_position(p->plocks, t->tlocks);
+  // printf("userinit\n");
   release(&p->lock);
+  // printf("userinit0\n");
 }
 
 // Grow or shrink user memory by n bytes.
@@ -566,6 +576,9 @@ int fork(void)
 
   pid = np->pid;
   release(&nt->lock);
+  nt->tlocks[7]--;
+  np->plocks[0]--;
+  // printf("fork1\n");
   release(&np->lock);
 
   // printf("DEBUG -----fork - acquire wait_lock \n");
@@ -575,12 +588,16 @@ int fork(void)
 
   // printf("DEBUG ----- fork - acquire proc %d lock \n", np->pid);
   acquire(&np->lock);
+  np->plocks[0]++;
   np->state = RUNNABLE;
   // np->threads[0].state = RUNNABLE; //Ass2 - Task3
   nt->state = RUNNABLE; //Ass2 - Task3
-
+  np->plocks[0]--;
+  // printf("fork2\n");
   release(&np->lock);
+
   // printf("DEBUG ---- thread %d of proc %s was forked\n", nt->tid, nt->parent->name);
+  // printf("fork0\n");
   return pid;
 }
 
@@ -646,28 +663,36 @@ void exit(int status)
   // wakeup(p->parent);
   printf("DEBUG ---- exiting1 \n");
   acquire(&p->lock);
-  p->plocks[1] = 1;
+  p->plocks[1]++;
   printf("DEBUG ---- exiting2 \n");
+  acquire(&t->lock);
 
   p->xstate = status;
   p->state = ZOMBIE;
-  // t->state = ZOMBIE;
-
+  t->state = ZOMBIE;
+  release(&t->lock);
   // for (int i = 0; i < NTHREAD; i++)
   struct thread *nt;
   for (nt = p->threads; nt < &p->threads[NTHREAD]; nt++)
   {
+    // if (t != nt)
+    // {
     //FIXME: how do we kill all threads
     // p->currThreads[i].killed = 1;
-    acquire(&t->lock);
-    t->tlocks[1] = 1;
-    t->state = ZOMBIE;
-    t->tlocks[1] = 0;
-    release(&t->lock);
+    // print_locks_position(p->plocks, nt->tlocks);
+    acquire(&nt->lock);
+    nt->tlocks[1]++;
+    nt->state = ZOMBIE;
+    nt->tlocks[1]--;
+    release(&nt->lock);
+    // }
   }
-  //TODO: Do we need this?
   acquire(&t->lock);
-  t->tlocks[2] = 1;
+
+  //TODO: Do we need this?
+  printf("DEBUG ---- exiting3\n");
+  // acquire(&t->lock);
+  // t->tlocks[2]++;
   release(&wait_lock);
   // Jump into the scheduler, never to return.
   // printf("DEBUG ---- thread  %d finish to exit\n", myThread()->tid);
@@ -755,7 +780,7 @@ void scheduler(void)
     for (p = proc; p < &proc[NPROC]; p++)
     {
       acquire(&p->lock);
-      p->plocks[2] = 1;
+      p->plocks[2]++;
       // printf("DEBUG ---- CPU %d acquire proc %d\n", cpuid(), p->pid);
 
       if (p->state == RUNNABLE || p->state == RUNNING)
@@ -779,13 +804,14 @@ void scheduler(void)
           {
             // printf("\nDEBUG ----  %d:\tfound thread %d to run\n",cpuid(), t->tid);
             acquire(&t->lock);
-            t->tlocks[3] = 1;
+            t->tlocks[3]++;
             t->state = RUNNING;
             c->currThread = t;
             swtch(&c->context, &t->context);
             c->currThread = 0;
-            t->tlocks[3] = 0;
+            t->tlocks[3]--;
             release(&t->lock);
+            break;
           }
           // printf("DEBUG ---- swtch done\n");
           // printf("DEBUG ---- %d:\trelease thread %d of proc %d\n", cpuid(), t->tid, p->pid);
@@ -796,7 +822,7 @@ void scheduler(void)
         c->proc = 0;
       }
       // printf("DEBUG ---- CPU %d release proc %d\n", cpuid(), p->pid);
-      p->plocks[2] = 0;
+      p->plocks[2]--;
       release(&p->lock);
     }
   }
@@ -831,16 +857,6 @@ void sched(void)
   swtch(&t->context, &mycpu()->context);
   mycpu()->intena = intena;
 }
-// //Proc yield
-// // Give up the CPU for one scheduling round.
-// void yield(void)
-// {
-//   struct proc *p = myproc();
-//   acquire(&p->lock);
-//   p->state = RUNNABLE;
-//   sched();
-//   release(&p->lock);
-// }
 
 //Thread yield
 // Give up the CPU for one scheduling round.
@@ -849,22 +865,25 @@ void yield(void)
   struct proc *p = myproc();
   struct thread *t = myThread();
   printf("DEBUG ---- yielding1 \n");
+  // print_locks_position(p->plocks, t->tlocks);
   acquire(&p->lock);
-  p->plocks[3] = 1;
+  p->plocks[3]++;
   printf("DEBUG ---- yielding2\n");
-  p->state = RUNNABLE;
-  // print_locks_position(p->plocks, t->tlocks);
+  print_locks_position(p->plocks, t->tlocks);
   acquire(&t->lock);
-  t->tlocks[4] = 1;
-
+  t->tlocks[4]++;
+  p->state = RUNNABLE;
   printf("DEBUG ---- yielding3\n");
   t->state = RUNNABLE;
 
   // printf("DEBUG ***** yield sched,\t proc %d \t thread %d\n", p->pid, t->tid);
   sched();
+  t->tlocks[4]--;
   release(&t->lock);
-  t->tlocks[4] = 0;
-  p->plocks[3] = 0;
+
+  p->plocks[3]--;
+  // print_locks_position(p->plocks, t->tlocks);
+  // printf("yield\n");
   release(&p->lock);
 }
 
@@ -911,9 +930,9 @@ void sleep(void *chan, struct spinlock *lk)
   // (wakeup locks p->lock),
   // so it's okay to release lk.
   acquire(&p->lock); //DOC: sleeplock1
-  p->plocks[4] = 1;
+  p->plocks[4]++;
   acquire(&t->lock); //DOC: sleeplock1
-  t->tlocks[5] = 1;
+  t->tlocks[5]++;
 
   release(lk);
 
@@ -928,11 +947,13 @@ void sleep(void *chan, struct spinlock *lk)
   t->chan = 0;
 
   // Reacquire original lock.
-  t->tlocks[5] = 0;
+  t->tlocks[5]--;
 
   release(&t->lock);
 
-  p->plocks[4] = 0;
+  p->plocks[4]--;
+  // print_locks_position(p->plocks, t->tlocks);
+  // printf("sleep\n");
   release(&p->lock);
   acquire(lk);
 }
@@ -978,7 +999,7 @@ int kill(int pid, int signum)
   for (p = proc; p < &proc[NPROC]; p++)
   {
     acquire(&p->lock);
-    p->plocks[5] = 1;
+    p->plocks[5]++;
     //check if signal already on
     //Do we really need to check if ZOMBIE?
     if (((p->pendingSig & 1 << signum) == 0) && (p->pid == pid) && (p->state != ZOMBIE))
@@ -995,10 +1016,10 @@ int kill(int pid, int signum)
           for (t = p->threads; t < &p->threads[NTHREAD]; t++)
           {
             acquire(&t->lock);
-            t->tlocks[6] = 1;
+            t->tlocks[6]++;
             t->killed = 1;
             t->state = RUNNABLE;
-            t->tlocks[6] = 0;
+            t->tlocks[6]--;
             release(&t->lock);
           }
         }
@@ -1016,10 +1037,12 @@ int kill(int pid, int signum)
         p->pendingSig = p->pendingSig + (1 << signum);
         break;
       }
+      // printf("kill1\n");
       release(&p->lock);
       return 0;
     }
-    p->plocks[5] = 0;
+    p->plocks[5]--;
+    // printf("kill2\n");
     release(&p->lock);
   }
   return -1;
@@ -1030,7 +1053,7 @@ uint sigprocmask(uint sigmask)
 {
   struct proc *p = myproc();
   acquire(&p->lock);
-  p->plocks[6] = 1;
+  p->plocks[6]++;
   uint oldMask = p->sigMask;
   p->sigMask = sigmask;
   release(&p->lock);
@@ -1050,8 +1073,9 @@ int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
   if (act != 0)
   {
     acquire(&p->lock);
-    p->plocks[7] = 1;
+    p->plocks[7]++;
     p->sigHandlers[signum] = (struct sigaction *)act; //without casting makes an error becouse it's const
+    p->plocks[7]--;
     release(&p->lock);
   }
   if (oldact != 0)
@@ -1115,21 +1139,28 @@ void kthread_exit(int status)
   //TODO: Implement
   struct proc *p = myproc();
   struct thread *t = myThread();
-
+  printf("KTHREAD_EXIT\n");
+  print_locks_position(p->plocks,t->tlocks);
   //last thread of the first proc
-  // if (p == initproc && p->tCounter == 1)
-
-  if (p == initproc)
+  if (p == initproc && p->tCounter == 1)
     panic("init exiting");
 
+  // if (p == initproc)
+  //   panic("init exiting");
+
   // last thread of the proc
-  // if (p->tCounter == 1)
-  // {
-  // exit(status);
-  // return;
-  // }
+  if (p->tCounter == 1)
+  {
+    printf("kthread-exit2\n");
+    exit(status);
+    return;
+  }
   // print_locks_position(p->plocks, t->tlocks);
+  acquire(&p->lock);
+  printf("kthread-exit3\n");
   acquire(&t->lock);
+  printf("kthread-exit4\n");
+
   t->xstate = status;
   //t->killed = 1;
   t->state = ZOMBIE;
diff --git a/kernel/proc.h b/kernel/proc.h
index 188d5a1..fcbaab6 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -143,4 +143,5 @@ struct proc
   //Ass2 - Task3
   struct thread threads[NTHREAD];
   int plocks[8];
+  int tCounter;
 };
diff --git a/kernel/spinlock.c b/kernel/spinlock.c
index 9bf2cc3..8e38680 100644
--- a/kernel/spinlock.c
+++ b/kernel/spinlock.c
@@ -22,6 +22,7 @@ void acquire(struct spinlock *lk)
   push_off(); // disable interrupts to avoid deadlock.
   if (holding(lk))
   {
+    printf("lock: %s\n",lk->name);
     panic("acquire");
   }
 
@@ -46,7 +47,9 @@ void acquire(struct spinlock *lk)
 void release(struct spinlock *lk)
 {
   if (!holding(lk))
+  {
     panic("release");
+  }
 
   lk->cpu = 0;
 
diff --git a/user/ourTest.c b/user/ourTest.c
index 4b8ea85..92e7c05 100644
--- a/user/ourTest.c
+++ b/user/ourTest.c
@@ -27,6 +27,7 @@ void runner3()
 {
     for (int i = 0; i < 5; i++)
         printf(": I LOVE YOU BABY\n", kthread_id());
+    printf("\n%d love-done \n", kthread_id());
     kthread_exit(0);
 }
 int main(int argc, char *argv[])
@@ -40,7 +41,7 @@ int main(int argc, char *argv[])
 
     if (pid == 0)
     {
-        //first function gets address 0 
+        //first function gets address 0
         // printf("function runner1 gets address >  %p\n", runner1);
         // printf("create - gets runner pointer %p\n", runner2);
         // printf("create - gets runner pointer %p\n", runner3);
@@ -51,6 +52,7 @@ int main(int argc, char *argv[])
         {
             printf("%d: I need YOU BABY\n ", kthread_id());
         }
+        printf("\n%d need-done \n", kthread_id());
     }
     else if (pid == -1)
     {
@@ -62,5 +64,6 @@ int main(int argc, char *argv[])
         wait(&status);
     }
 
-    exit(0);
+    kthread_exit(0);
+    return 0;
 }
